## 函数 ##
### 参数传递 ###
当形参是引用类型时，我们说它对应的实参**被引用传递**或者函数被**传引用调用**。
当实参的值被拷贝给形参时，形参和实参是两个相互独立的变量。我们说这样的实参被**值传递**或者函数被**传值调用**
### 传值参数 ###
这种情况下函数对形参做的所有操作都不影响实参。
### 指针形参 ###
这种情况会多一个**拷贝**操作，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针，但是通过指针可以修改它所指的对象的值。
**实参所指的对象变了，但是实参本身并没有变化**
### 传引用参数 ###
```cpp
void reset(int &i){
	i = 0;				//改变了i所引对象的值
}
```
### 在使用的过程中，尽量使用引用，避免拷贝 ###
拷贝大的类类型对象或者容器对象比较低效，甚至有的类型根本不支持拷贝操作。
### 使用引用可以返回额外的信息 ###
用于想要让一个函数返回多个值。
虽然只能return一个值，但是通过参数加引用，可以多个返回值。
```cpp
string::size_type find_char(const string &s, char c, string::size_type &occurs){
	auto ret = s.size();
	occurs = 0;
	for(decltype(ret) i = 0; i != s.size(); ++i){
		if(s[i] == c){
			if(ret == s.size())
				ret = i;
			++occurs;
		}
	}
	return ret;
}
```
### 尽量使用常量引用 ###
把函数不会改变的形参定义成普通的引用是一种比较常见的错误，会带来一种误导，即函数可以修改它的实参的值，而且还会限制函数所能接受的实参类型。
比如，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用实参。
```cpp
//不良设计：第一个形参的类型应该是const string&
string::size_type find_char(string &s, char c, string::size_type &occurs);
```
如果出现这样的调用就会报错：
```cpp
find_char("Hello World",'o',ctr);
```